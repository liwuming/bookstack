(window.webpackJsonp=window.webpackJsonp||[]).push([[9],{355:function(n,t,o){"use strict";o.r(t);var v=o(42),_=Object(v.a)({},(function(){var n=this,t=n.$createElement,o=n._self._c||t;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h1",{attrs:{id:"锁机制"}},[n._v("锁机制")]),n._v(" "),o("h2",{attrs:{id:"什么是锁"}},[n._v("什么是锁")]),n._v(" "),o("p",[n._v("锁机制是数据库系统区别与文件系统的一个关键特性，用于管理对共享资源的并发访问，保证数据的完整性和一致性。只有正确了解锁机制，才能完全发挥innodb存储引擎在锁方面的优势；")]),n._v(" "),o("p",[n._v("innodb存储引擎锁的实现和oracle非常类似，提供一致性的非锁定读，行级锁支持，行级锁没有相关开销，可以同时得到并发性和一致性；")]),n._v(" "),o("h2",{attrs:{id:"innodb存储引擎中的索引"}},[n._v("innodb存储引擎中的索引")]),n._v(" "),o("p",[n._v("innodb存储引擎实现了两种标准的行级锁：\n共享锁(s lock)：允许事务读一行数据\n排他锁(x lock)：允许事务删除或者更新一行数据")]),n._v(" "),o("p",[n._v("共享锁与排他锁的兼容性")]),n._v(" "),o("p",[n._v("innodb存储引擎支持多粒度锁定，这种锁定允许在行级别上的锁和表级别上的锁同时存在，为了支持在不同粒度上进行加锁操作，innodb存储引擎支持一种额外的锁方式--意向锁，意向锁是表级别的锁，其设计目主要是为了在一个事务中揭示下一行将被请求的锁的类型，innodb存储引擎支持两种意向锁：\n意向共享锁(IS lock):事务想要获得一个表中的某几行的共享锁\n意向排他锁(IX lock)：事务想要获得一个表中某几行的排他锁")]),n._v(" "),o("h1",{attrs:{id:"事务"}},[n._v("事务")]),n._v(" "),o("p",[n._v("事务是什么？\n数据库事务是数据库管理系统执行过程中的一个逻辑单元，有一个有限的数据库操作序列构成。\n--维基百科")]),n._v(" "),o("p",[n._v("事务是用来保证数据库数据的完整性，是数据库管理系统区别于文件系统的重要特性之一，拥有以下四个特性，习惯上称之为ACID特性：\nA():原子性\nC():一致性\nI():隔离性\nD():持久性")]),n._v(" "),o("h2",{attrs:{id:"事务的实现"}},[n._v("事务的实现")]),n._v(" "),o("p",[n._v("隔离性由锁机制得以实现，原子性、一致性、持久性通过数据库的redo和undo来完成；")]),n._v(" "),o("p",[n._v("redo\n事务日志通过重做日志文件和innodb存储引擎的日志缓冲来实现。\n当开始一个事务时，会记录该事务的LSN--日志序列号；\n当事务执行时，会往innodb存储引擎的日志缓冲里插入事务日志；\n当提交事务时，必须将innodb存储引擎的日志缓冲写入磁盘，也就是说在写入数据前，需要先写入日志，这种方式称之为WAL--预写日志方式；")]),n._v(" "),o("p",[n._v("undo\n与redo不同的是，redo存放在重做日志文件中，undo存放在数据库内部的一个特殊段中，这称为undo段，undo段位于共享表空间内；")]),n._v(" "),o("h2",{attrs:{id:"事务的控制语句"}},[n._v("事务的控制语句")]),n._v(" "),o("p",[n._v("在MySQL命令行的默认设置下，事务都是自动提交的，即执行SQL语句后就会马上执行commit操作\n如何显示的开启一个事务呢？\nstart transction/begin语句都都可以显示的开启一个事务，但是在存储过程中，只能使用start transaction语句来开启一个事务")])])}),[],!1,null,null,null);t.default=_.exports}}]);